import { OntoumlElement, OntoumlType, Class, ClassStereotype, OntologicalNature, PropertyStereotype, RelationStereotype, Generalization, GeneralizationSet, Literal, ModelElement, ModelElementContainer, Property, Relation, Classifier } from '..';
export declare class Package extends ModelElement implements ModelElementContainer {
    contents: ModelElement[];
    constructor(base?: Partial<Package>);
    addContent<T extends ModelElement>(child: T): T;
    addContents<T extends ModelElement>(contents: T[]): T[];
    setContents<T extends ModelElement>(contents: T[]): T[];
    removeContent<T extends ModelElement>(child: T): T;
    getContents(): OntoumlElement[];
    getElementById(id: String): OntoumlElement;
    getClassById(id: String): Class;
    getRelationById(id: String): Relation;
    getPropertyById(id: String): Property;
    getGeneralizationById(id: String): Generalization;
    getGeneralizationSetById(id: String): GeneralizationSet;
    getPackageById(id: String): Package;
    getAllProperties(): Property[];
    getAllAttributes(): Property[];
    getAllRelationEnds(): Property[];
    getAllRelations(): Relation[];
    getAllGeneralizations(): Generalization[];
    getAllGeneralizationSets(): GeneralizationSet[];
    getAllPackages(): Package[];
    getAllClasses(): Class[];
    getAllEnumerations(): Class[];
    getAllLiterals(): Literal[];
    getAllModelElements(): ModelElement[];
    getAllContentsByType(type: OntoumlType | OntoumlType[]): OntoumlElement[];
    getAllAttributesByStereotype(stereotype: PropertyStereotype | PropertyStereotype[]): Property[];
    getAllClassesByStereotype(stereotype: ClassStereotype | ClassStereotype[]): Class[];
    getAllRelationsByStereotype(stereotype: RelationStereotype | RelationStereotype[]): Relation[];
    getAllClassesWithRestrictedToContainedIn(nature: OntologicalNature | OntologicalNature[]): Class[];
    getClassesWithTypeStereotype(): Class[];
    getClassesWithHistoricalRoleStereotype(): Class[];
    getClassesWithHistoricalRoleMixinStereotype(): Class[];
    getClassesWithEventStereotype(): Class[];
    getClassesWithSituationStereotype(): Class[];
    getClassesWithCategoryStereotype(): Class[];
    getClassesWithMixinStereotype(): Class[];
    getClassesWithRoleMixinStereotype(): Class[];
    getClassesWithPhaseMixinStereotype(): Class[];
    getClassesWithKindStereotype(): Class[];
    getClassesWithCollectiveStereotype(): Class[];
    getClassesWithQuantityStereotype(): Class[];
    getClassesWithRelatorStereotype(): Class[];
    getClassesWithQualityStereotype(): Class[];
    getClassesWithModeStereotype(): Class[];
    getClassesWithSubkindStereotype(): Class[];
    getClassesWithRoleStereotype(): Class[];
    getClassesWithPhaseStereotype(): Class[];
    getClassesWithEnumerationStereotype(): Class[];
    getClassesWithDatatypeStereotype(): Class[];
    getClassesWithAbstractStereotype(): Class[];
    getClassesRestrictedToFunctionalComplex(): Class[];
    getClassesRestrictedToCollective(): Class[];
    getClassesRestrictedToQuantity(): Class[];
    getClassesRestrictedToMode(): Class[];
    getClassesRestrictedToIntrinsicMode(): Class[];
    getClassesRestrictedToExtrinsicMode(): Class[];
    getClassesRestrictedToQuality(): Class[];
    getClassesRestrictedToRelator(): Class[];
    toJSON(): any;
    createPackage(name?: string, base?: Partial<Package>): Package;
    createClass(name?: string, stereotype?: ClassStereotype, natures?: OntologicalNature | OntologicalNature[], base?: Partial<Class>): Class;
    createType(name?: string, base?: Partial<Class>): Class;
    createHistoricalRole(name?: string, base?: Partial<Class>): Class;
    createHistoricalRoleMixin(name?: string, natures?: OntologicalNature | OntologicalNature[], base?: Partial<Class>): Class;
    createEvent(name?: string, base?: Partial<Class>): Class;
    createSituation(name?: string, base?: Partial<Class>): Class;
    createCategory(name?: string, natures?: OntologicalNature | OntologicalNature[], base?: Partial<Class>): Class;
    createMixin(name?: string, natures?: OntologicalNature | OntologicalNature[], base?: Partial<Class>): Class;
    createRoleMixin(name?: string, natures?: OntologicalNature | OntologicalNature[], base?: Partial<Class>): Class;
    createPhaseMixin(name?: string, natures?: OntologicalNature | OntologicalNature[], base?: Partial<Class>): Class;
    createKind(name?: string, base?: Partial<Class>): Class;
    createCollective(name?: string, isExtensional?: boolean, base?: Partial<Class>): Class;
    createQuantity(name?: string, base?: Partial<Class>): Class;
    createRelator(name?: string, base?: Partial<Class>): Class;
    createQuality(name?: string, base?: Partial<Class>): Class;
    createIntrinsicMode(name?: string, base?: Partial<Class>): Class;
    createExtrinsicMode(name?: string, base?: Partial<Class>): Class;
    createSubkind(name?: string, nature?: OntologicalNature, base?: Partial<Class>): Class;
    createRole(name?: string, nature?: OntologicalNature, base?: Partial<Class>): Class;
    createPhase(name?: string, nature?: OntologicalNature, base?: Partial<Class>): Class;
    createAbstract(name?: string, base?: Partial<Class>): Class;
    createDatatype(name?: string, base?: Partial<Class>): Class;
    createEnumeration(name?: string, literals?: Partial<Literal>[], base?: Partial<Class>): Class;
    createRelation(base?: Partial<Relation>): Relation;
    createBinaryRelation(source: Class, target: Class, name?: string, stereotype?: RelationStereotype, base?: Partial<Relation>): Relation;
    createDerivationRelation(derivingRelation: Relation, derivedClass: Class, name?: string, base?: Partial<Relation>): Relation;
    createTernaryRelation(relata: Class[], name?: string, base?: Partial<Relation>): Relation;
    createMaterialRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createComparativeRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createMediationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createCharacterizationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createExternalDependencyRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createComponentOfRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createMemberOfRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createSubCollectionOfRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createSubQuantityOfRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createInstantiationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createTerminationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createParticipationalRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createParticipationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createHistoricalDependenceRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createCreationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createManifestationRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createBringsAboutRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createTriggersRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createPartWholeRelation(source: Class, target: Class, name?: string, base?: Partial<Relation>): Relation;
    createGeneralization(general: Classifier<any, any>, specific: Classifier<any, any>, name?: string, base?: Partial<Generalization>): Generalization;
    createGeneralizationSet(generalizations: Generalization | Generalization[], isDisjoint?: boolean, isComplete?: boolean, categorizer?: Class, name?: string, base?: Partial<GeneralizationSet>): GeneralizationSet;
    createPartition(generalizations: Generalization | Generalization[], categorizer?: Class, name?: string, base?: Partial<GeneralizationSet>): GeneralizationSet;
    createPartitionFromClasses(general: Class, specifics: Class[], name?: string): GeneralizationSet;
    createGeneralizationSetFromClasses(general: Class, specifics: Class[], isDisjoint?: boolean, isComplete?: boolean, name?: string): GeneralizationSet;
    clone(replaceReferences?: boolean): Package;
    replace(originalElement: ModelElement, newElement: ModelElement): void;
    static triggersReplaceOnClonedPackage(originalPackage: Package, clonedPackage: Package): void;
}
